{
  "title": "RS Modifier, Property, and Drawable System in OpenHarmony graphic_2d",
  "slug": "rs-modifier-property-drawable-system-openharmony",
  "excerpt": "Deep dive into the three core systems that control visual rendering in OpenHarmony's graphic_2d framework: Modifier System, Property System, and Drawable System. Learn how properties flow from client changes to GPU rendering through the prepare and render phases.",
  "content": "# RS Modifier, Property, and Drawable System in OpenHarmony graphic_2d\r\n\r\n## Overview\r\n\r\nThis document focuses on the three core systems that control visual rendering in OpenHarmony's graphic_2d framework:\r\n\r\n1. **Modifier System** - Defines what visual properties a node has\r\n2. **Property System** - Manages individual property values and their changes\r\n3. **Drawable System** - Converts properties into actual GPU rendering\r\n\r\n**Architecture Summary:**\r\n```\r\nProperty Change → Modifier (encapsulates properties) → Dirty Flags → RSProperties (prepare phase)\r\n                                                                       ↓\r\n                                                                  Drawable (created)\r\n                                                                       ↓\r\n                                                                  OnDraw() (render phase)\r\n```\r\n\r\n---\r\n\r\n## 1. Modifier System\r\n\r\nLocation:\r\n- `rosen/modules/render_service_client/core/modifier_ng/`\r\n- `rosen/modules/render_service_base/include/modifier_ng/`\r\n\r\n### Overview\r\n\r\nModifiers are components that define the visual appearance and behavior of RS nodes. They encapsulate properties like position, size, color, shadows, filters, etc.\r\n\r\n**Key characteristics:**\r\n- Each modifier has a specific type defined by `RSModifierType`\r\n- Modifiers are client-side objects that mirror server-side `RSRenderModifier` objects\r\n- They can be animatable or non-animatable\r\n- **NG** (Next Generation) suffix denotes enhanced implementations with better performance\r\n\r\n### RSModifierType Enum\r\n\r\nLocation: `rosen/modules/render_service_base/include/modifier_ng/rs_modifier_ng_type.h`\r\n\r\n```cpp\r\nenum class RSModifierType : uint16_t {\r\n    INVALID = 0,\r\n\r\n    // Geometry\r\n    BOUNDS = 1,\r\n    FRAME = 2,\r\n    TRANSFORM = 3,\r\n\r\n    // Appearance\r\n    ALPHA = 4,\r\n    FOREGROUND_COLOR = 5,\r\n    BACKGROUND_COLOR = 6,\r\n    BACKGROUND_SHADER = 7,\r\n    BACKGROUND_IMAGE = 8,\r\n    BORDER = 9,\r\n    OUTLINE = 10,\r\n\r\n    // Clipping\r\n    CLIP_TO_BOUNDS = 11,\r\n    CLIP_TO_FRAME = 12,\r\n\r\n    // Effects\r\n    SHADOW = 15,\r\n    MASK = 16,\r\n    DYNAMIC_LIGHT_UP = 14,\r\n    PIXEL_STRETCH = 17,\r\n    USE_EFFECT = 18,\r\n    BLENDER = 19,\r\n\r\n    // Particles & Lighting\r\n    POINT_LIGHT = 20,\r\n    PARTICLE_EFFECT = 21,\r\n\r\n    // Filters\r\n    COMPOSITING_FILTER = 22,\r\n    BACKGROUND_FILTER = 23,\r\n    FOREGROUND_FILTER = 24,\r\n\r\n    // Styles\r\n    TRANSITION_STYLE = 25,\r\n    BACKGROUND_STYLE = 26,\r\n    CONTENT_STYLE = 27,\r\n    FOREGROUND_STYLE = 28,\r\n    OVERLAY_STYLE = 29,\r\n    NODE_MODIFIER = 30,\r\n\r\n    // NG (Next Generation) variants\r\n    BACKGROUND_NG_SHADER = 34,\r\n    FOREGROUND_SHADER = 35,\r\n    MATERIAL_FILTER = 36,\r\n    COLOR_PICKER = 37,\r\n\r\n    // Special\r\n    CHILDREN,  // Placeholder for dirty flag\r\n    MAX = CHILDREN + 1,\r\n};\r\n```\r\n\r\n### Key Classes\r\n\r\n| Client Side | Server Side | Purpose |\r\n|-------------|-------------|---------|\r\n| `RSModifier` | `RSRenderModifier` | Base modifier class |\r\n| `RSAlphaModifier` | `RSAlphaRenderModifier` | Alpha modifier |\r\n| `RSBackgroundColorModifier` | `RSBackgroundColorRenderModifier` | Background color modifier |\r\n| `RSShadowModifier` | `RSShadowRenderModifier` | Shadow modifier |\r\n| `RSFilterModifier` | `RSFilterRenderModifier` | Filter effects |\r\n\r\n### NG (Next Generation) System\r\n\r\nThe NG suffix denotes the next-generation architecture:\r\n- **Better performance**: Optimized dirty tracking\r\n- **Cleaner design**: Separation of client/render modifiers\r\n- **More features**: Support for complex effects (filters, shaders, masks)\r\n- **Improved animation**: Better integration with animation system\r\n\r\n### Advanced Features\r\n\r\n- **Animation Support**: Modifiers can be animated with various timing curves\r\n- **Custom Modifiers**: `RSCustomModifier` for custom behavior\r\n- **Property Inheritance**: Child nodes inherit parent modifiers\r\n- **Dirty Optimization**: Only dirty modifiers are processed each frame\r\n\r\n---\r\n\r\n## 2. Property System\r\n\r\nLocation:\r\n- `rosen/modules/render_service_client/core/modifier/`\r\n- `rosen/modules/render_service_base/src/property/`\r\n\r\n### Overview\r\n\r\nProperties are the individual values within modifiers. Each property holds a specific value (color, alpha, position, etc.) and manages its own updates and dirty state.\r\n\r\n### RSPropertyType Enum\r\n\r\nLocation: `rosen/modules/render_service_base/include/modifier_ng/rs_property_ng_type.h`\r\n\r\nGenerated from `rs_property_ng_type.in`, includes hundreds of individual properties:\r\n\r\n```cpp\r\nenum class RSPropertyType : uint16_t {\r\n    INVALID,\r\n\r\n    // Geometry properties\r\n    BOUNDS, FRAME, POSITION_Z, ROTATION, SCALE, TRANSLATE, CORNER_RADIUS,\r\n\r\n    // Appearance properties\r\n    ALPHA, FOREGROUND_COLOR, BACKGROUND_COLOR, BACKGROUND_SHADER, BG_IMAGE,\r\n\r\n    // Border properties\r\n    BORDER_COLOR, BORDER_WIDTH, BORDER_RADIUS,\r\n\r\n    // Shadow properties\r\n    SHADOW_COLOR, SHADOW_OFFSET_X, SHADOW_OFFSET_Y, SHADOW_RADIUS, SHADOW_ELEVATION,\r\n\r\n    // Clipping properties\r\n    CLIP_TO_BOUNDS, CLIP_TO_FRAME,\r\n\r\n    // Filter & Effect properties\r\n    FILTER, BACKGROUND_FILTER, FOREGROUND_FILTER,\r\n    MASK, SHADOW, BLENDER,\r\n\r\n    // ... hundreds more properties\r\n};\r\n```\r\n\r\n### Property Classes\r\n\r\n| Class | Purpose |\r\n|-------|---------|\r\n| `RSPropertyBase` | Abstract base for all properties |\r\n| `RSProperty<T>` | Generic property implementation |\r\n| `RSAnimatableProperty<T>` | Animation-capable property with staging/showing values |\r\n| `RSRenderProperty<T>` | Server-side property representation |\r\n\r\n### Property Update Types\r\n\r\n```cpp\r\nenum PropertyUpdateType {\r\n    OVERWRITE,        // Direct value replacement\r\n    INCREMENTAL,      // Incremental updates\r\n    FORCE_OVERWRITE,  // Forced update regardless of current value\r\n    ONLY_VALUE        // Value-only update (no animation)\r\n};\r\n```\r\n\r\n### RSAnimatableProperty: Staging vs Showing Values\r\n\r\nFor animated properties, the system maintains two separate values:\r\n\r\n```cpp\r\nclass RSAnimatableProperty<T> : public RSProperty<T> {\r\nprivate:\r\n    T stagingValue_;  // Client-side target value\r\n    T showingValue_;  // Current interpolated value (for animation)\r\n};\r\n```\r\n\r\n- **`stagingValue_`**: The target value set by the client (e.g., SetAlpha(0.5f))\r\n- **`showingValue_`**: The current value being displayed (interpolated during animation)\r\n- During animation: `showingValue_` gradually approaches `stagingValue_`\r\n- Animation completion detected when values are within threshold distance\r\n\r\n### Property Lifecycle\r\n\r\n```\r\nSet(value) → MarkNodeDirty() → Update staging value → Create RSCommand\r\n                                ↓\r\n                              IPC\r\n                                ↓\r\n                    Server receives command\r\n                                ↓\r\n                    ApplyModifiers() → Update RSProperties\r\n                                ↓\r\n                    OnSync() → Sync staging to render value\r\n```\r\n\r\n### Dirty Flag System\r\n\r\nThe system uses a sophisticated dirty tracking mechanism to optimize rendering:\r\n\r\n#### ModifierDirtyTypes\r\n```cpp\r\nusing ModifierDirtyTypes = std::bitset<static_cast<int>(MODIFIER_TYPE_COUNT)>;\r\n```\r\nA bitset that tracks which modifier types are dirty. Each bit corresponds to a modifier type.\r\n\r\n#### How Dirty Flags Work\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                    1. Property Change (Client Side)                     │\r\n│                                                                         │\r\n│   node->SetAlpha(0.5f)  →  RSProperty::Set(value)                       │\r\n│                           ↓                                              │\r\n│                    MarkNodeDirty(RSModifierType::ALPHA)                 │\r\n│                           ↓                                              │\r\n│            dirtyTypes_.set(static_cast<int>(ALPHA))                     │\r\n└─────────────────────────────────────┬───────────────────────────────────┘\r\n                                      │\r\n                                      ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                      2. Dirty Tracking                                   │\r\n│                                                                         │\r\n│   ModifierDirtyTypes dirtyTypes_ = bitset<modifier count>               │\r\n│                                                                         │\r\n│   Each bit represents: Is this modifier type dirty?                     │\r\n│   Example: 0b000010000  → ALPHA modifier is dirty                       │\r\n└─────────────────────────────────────┬───────────────────────────────────┘\r\n                                      │\r\n                                      ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                      3. Calculate Dirty Slots                           │\r\n│                                                                         │\r\n│   CalculateDirtySlotsNG(dirtyTypes, drawableVec)                        │\r\n│                           ↓                                              │\r\n│   Maps dirty modifier types → drawable slots that need update           │\r\n│                                                                         │\r\n│   Example: ALPHA dirty → FOREGROUND_COLOR slot dirty                    │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Property-Drawable Lookup Table\r\n\r\nThe system uses a lookup table to map modifier types to drawable slots:\r\n\r\n```cpp\r\nstatic const std::unordered_map<RSModifierType, RSDrawableSlot>\r\n    g_propertyToDrawableLutNG = {\r\n    // Background\r\n    { RSModifierType::BACKGROUND_COLOR, RSDrawableSlot::BACKGROUND_COLOR },\r\n    { RSModifierType::BACKGROUND_IMAGE, RSDrawableSlot::BACKGROUND_IMAGE },\r\n    { RSModifierType::BACKGROUND_SHADER, RSDrawableSlot::BACKGROUND_SHADER },\r\n    { RSModifierType::BACKGROUND_FILTER, RSDrawableSlot::BACKGROUND_FILTER },\r\n\r\n    // Foreground\r\n    { RSModifierType::FOREGROUND_COLOR, RSDrawableSlot::FOREGROUND_COLOR },\r\n    { RSModifierType::FOREGROUND_SHADER, RSDrawableSlot::FOREGROUND_SHADER },\r\n    { RSModifierType::FOREGROUND_FILTER, RSDrawableSlot::FOREGROUND_FILTER },\r\n\r\n    // Effects\r\n    { RSModifierType::SHADOW, RSDrawableSlot::SHADOW },\r\n    { RSModifierType::MASK, RSDrawableSlot::MASK },\r\n    { RSModifierType::FILTER, RSDrawableSlot::FILTER },\r\n    { RSModifierType::BLENDER, RSDrawableSlot::BLENDER },\r\n\r\n    // ... 40+ mappings total\r\n};\r\n```\r\n\r\n---\r\n\r\n## 3. Drawable System\r\n\r\nLocation:\r\n- `rosen/modules/render_service_base/include/drawable/`\r\n- `rosen/modules/render_service_base/src/drawable/`\r\n- `rosen/modules/render_service/core/drawable/`\r\n\r\n### Overview\r\n\r\nDrawables are the rendering units that actually draw content on the GPU. They are created from RSNodes during the prepare phase and rendered during the render phase.\r\n\r\n### Core Drawable Classes\r\n\r\n| Class | Location | Purpose |\r\n|-------|----------|---------|\r\n| `RSDrawable` | `render_service_base/include/drawable/rs_drawable.h` | Base class for all drawables |\r\n| `RSRenderNodeDrawable` | `render_service/core/drawable/rs_render_node_drawable.cpp` | Main drawable implementation |\r\n| `RSPropertyDrawable` | `render_service_base/include/drawable/rs_property_drawable.h` | Base for property-based drawables |\r\n\r\n### RSDrawableSlot Enum\r\n\r\nDefines the rendering order for all drawable types:\r\n\r\n```cpp\r\nenum class RSDrawableSlot : int8_t {\r\n    // Background group (rendered first)\r\n    BACKGROUND_COLOR = 0,\r\n    BACKGROUND_IMAGE,\r\n    BACKGROUND_SHADER,\r\n    BACKGROUND_FILTER,\r\n\r\n    // Content group\r\n    CONTENT_STYLE,\r\n    CHILDREN,        // Child node drawables\r\n\r\n    // Foreground group (rendered after content)\r\n    FOREGROUND_COLOR,\r\n    FOREGROUND_SHADER,\r\n    FOREGROUND_FILTER,\r\n\r\n    // Effects (rendered on top)\r\n    SHADOW,\r\n    MASK,\r\n    FILTER,\r\n    BLENDER,\r\n\r\n    // Special slots for state management\r\n    SAVE_ALL,        // Save canvas state\r\n    RESTORE_ALL,     // Restore canvas state\r\n};\r\n```\r\n\r\n### Drawable Lifecycle\r\n\r\nEach drawable goes through a well-defined lifecycle:\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  1. OnGenerate()                                                        │\r\n│     - Factory method for drawable creation                              │\r\n│     - Static method: RSBackgroundColorDrawable::OnGenerate()            │\r\n│     - Returns nullptr if drawable not needed (e.g., transparent color) │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  2. OnUpdate()                                                          │\r\n│     - PREPARE PHASE (not actual rendering)                              │\r\n│     - Updates drawable content based on RSProperties                    │\r\n│     - Creates DrawCmdList for recording drawing operations              │\r\n│     - Only called for dirty drawables (optimization)                    │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  3. OnSync()                                                            │\r\n│     - Synchronizes staging values to render values                      │\r\n│     - Ensures render thread has latest data                             │\r\n│     - Thread-safe value transfer                                        │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  4. OnDraw()                                                             │\r\n│     - RENDER PHASE (actual GPU rendering)                                │\r\n│     - Executes the drawing commands                                     │\r\n│     - Uses pre-applied properties from RSProperties                     │\r\n│     - canvas.DrawRect(), canvas.DrawPath(), etc.                        │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  5. OnPurge()                                                            │\r\n│     - Cleanup when drawable is no longer needed                         │\r\n│     - Releases GPU resources                                            │\r\n│     - Returns drawable to pool for reuse                                │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Specialized Property Drawables\r\n\r\n| Drawable | Purpose | Properties Used |\r\n|----------|---------|-----------------|\r\n| `RSBackgroundColorDrawable` | Solid background color | `backgroundColor` |\r\n| `RSBackgroundImageDrawable` | Image background with GPU texture | `backgroundImage` |\r\n| `RSShadowDrawable` | Shadow effects with customizable parameters | `shadowColor`, `shadowOffset`, `shadowRadius` |\r\n| `RSFilterDrawable` | Complex visual effects | `filter` |\r\n| `RSMaskDrawable` | Clipping masks | `mask` |\r\n| `RSBlurFilterDrawable` | Blur effects | `blurRadius` |\r\n\r\n### Update vs Regenerate: When Properties Change\r\n\r\n**Answer: Drawables are Updated, Not Regenerated**\r\n\r\nWhen a property is changed, the corresponding drawable is **updated in place** via `OnUpdate()`, not regenerated via `OnGenerate()`. This is a key optimization that avoids unnecessary object creation.\r\n\r\n#### The Update Logic\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_drawable.cpp:482-513`\r\n\r\n```cpp\r\nbool RSDrawable::UpdateDirtySlots(\r\n    const RSRenderNode& node, Vec& drawableVec, std::unordered_set<RSDrawableSlot>& dirtySlots)\r\n{\r\n    for (const auto& slot : dirtySlots) {\r\n        if (auto& drawable = findMapValueRef(drawableVec, static_cast<int8_t>(slot))) {\r\n            // Drawable exists: UPDATE it\r\n            if (!drawable->OnUpdate(node)) {\r\n                // OnUpdate() returned false: PURGE the drawable\r\n                drawable.reset();\r\n            }\r\n        } else if (auto& generator = g_drawableGeneratorLut[static_cast<int>(slot)]) {\r\n            // Drawable doesn't exist: GENERATE it\r\n            if (auto drawable = generator(node)) {\r\n                drawableVec[static_cast<int8_t>(slot)] = std::move(drawable);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### Decision Flow\r\n\r\n```\r\nProperty Changed\r\n       ↓\r\nCalculateDirtySlotsNG() → Determine which RSDrawableSlot is affected\r\n       ↓\r\nFor each dirty slot:\r\n   ├─ Does drawable already exist?\r\n   │   ├─ YES → Call OnUpdate() → Update existing drawable\r\n   │   └─ NO  → Call OnGenerate() → Create new drawable\r\n   │\r\n   └─ OnUpdate() returns false?\r\n       ├─ YES → Purge drawable (destroy it)\r\n       └─ NO  → Keep drawable\r\n```\r\n\r\n#### When Each Action Occurs\r\n\r\n| Condition | Action | Method Called |\r\n|-----------|--------|--------------|\r\n| Drawable doesn't exist for slot | **Regenerate** | `OnGenerate()` |\r\n| Drawable exists + property changed | **Update** | `OnUpdate()` |\r\n| Property becomes invalid (transparent) | **Purge** | `drawable.reset()` |\r\n| OnUpdate() returns false | **Purge** | `drawable.reset()` |\r\n\r\n#### OnGenerate Calls OnUpdate\r\n\r\n`OnGenerate()` is actually a factory method that creates the drawable and immediately calls `OnUpdate()`:\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_property_drawable_background.cpp:253-259`\r\n\r\n```cpp\r\nRSDrawable::Ptr RSBackgroundColorDrawable::OnGenerate(const RSRenderNode& node)\r\n{\r\n    if (auto ret = std::make_shared<RSBackgroundColorDrawable>(); ret->OnUpdate(node)) {\r\n        return std::move(ret);  // Return if OnUpdate succeeds\r\n    }\r\n    return nullptr;\r\n}\r\n```\r\n\r\nSo `OnUpdate()` is where the real work happens - both during initial creation and during property updates!\r\n\r\n#### Example: Background Color Update\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_property_drawable_background.cpp:261-292`\r\n\r\n```cpp\r\nbool RSBackgroundColorDrawable::OnUpdate(const RSRenderNode& node)\r\n{\r\n    const RSProperties& properties = node.GetRenderProperties();\r\n    auto bgColor = properties.GetBackgroundColor();\r\n\r\n    // If transparent, this drawable should be purged\r\n    if (bgColor == RgbPalette::Transparent()) {\r\n        return false;  // Triggers purge\r\n    }\r\n\r\n    // Update the drawing commands with new color\r\n    RSPropertyDrawCmdListUpdater updater(0, 0, this);\r\n    Drawing::Canvas& canvas = *updater.GetRecordingCanvas();\r\n    Drawing::Brush brush;\r\n    brush.SetColor(bgColor.ConvertToDrawingColor());\r\n    canvas.AttachBrush(brush);\r\n    canvas.DrawRect(RSPropertiesPainter::Rect2DrawingRect(properties.GetBoundsRect()));\r\n    canvas.DetachBrush();\r\n\r\n    return true;  // Keep this drawable\r\n}\r\n```\r\n\r\n#### Key Differences Between OnGenerate and OnUpdate\r\n\r\n| Aspect | OnGenerate() | OnUpdate() |\r\n|--------|-------------|------------|\r\n| **When Called** | First creation, after purge | On property change |\r\n| **Purpose** | Create new drawable instance | Update existing drawable |\r\n| **Return Value** | Drawable pointer or nullptr | true (keep) or false (purge) |\r\n| **Performance** | Higher (creates new object) | Lower (updates existing) |\r\n\r\n### Prepare vs Render Phase (Critical Distinction)\r\n\r\n| Phase | Methods | What Happens |\r\n|-------|---------|--------------|\r\n| **Prepare** | `ApplyModifiers()`, `OnUpdate()` | Updates RSProperties, creates drawables, NO drawing |\r\n| **Render** | `OnDraw()` | Actual GPU rendering using pre-applied properties |\r\n\r\n**Key Point:** `ApplyModifiers()` updates `RSProperties` but does NOT draw. `OnDraw()` uses those pre-applied properties to actually render.\r\n\r\n---\r\n\r\n## 4. Complete Rendering Pipeline\r\n\r\n### Full Call Stack: SetBackgroundColor() Example\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     CLIENT PROCESS (Application)                        │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                    Property Change: SetBackgroundColor()\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     Modifier System (Client Side)                        │\r\n│                                                                         │\r\n│  RSBackgroundColorModifier::SetBackgroundColor()                        │\r\n│  → RSProperty<Color>::Set(stagingValue_)                                │\r\n│  → MarkNodeDirty(RSModifierType::BACKGROUND_COLOR)                      │\r\n│  → dirtyTypes_.set(BACKGROUND_COLOR)                                    │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     Transaction Marshalling                              │\r\n│                                                                         │\r\n│  RSAddModifierNG command created                                        │\r\n│  → Added to RSTransactionData                                           │\r\n│  → Marshalled to Parcel                                                 │\r\n│  → Sent via Binder IPC                                                  │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                        ════════════════════════\r\n                            IPC Boundary\r\n                        ════════════════════════\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     SERVER PROCESS (Render Service)                      │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     PREPARE PHASE                                        │\r\n│                                                                         │\r\n│  1. Receive RSAddModifierNG command                                     │\r\n│  2. RSRenderNode::AddModifier()                                         │\r\n│  3. Mark dirty: dirtyTypesNG_.set(BACKGROUND_COLOR)                     │\r\n│  4. ApplyModifiers()                                                    │\r\n│     → modifier->ApplyLegacyProperty(RSProperties)                       │\r\n│     → RSProperties::OnApplyModifiers()                                  │\r\n│     → Update internal RSProperties with color value                     │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     DIRTY SLOT CALCULATION                               │\r\n│                                                                         │\r\n│  CalculateDirtySlotsNG(dirtyTypesNG_)                                   │\r\n│  → Lookup in g_propertyToDrawableLutNG                                  │\r\n│  → BACKGROUND_COLOR modifier → RSDrawableSlot::BACKGROUND_COLOR        │\r\n│  → Mark BACKGROUND_COLOR slot as dirty                                  │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     DRAWABLE UPDATE                                      │\r\n│                                                                         │\r\n│  RSBackgroundColorDrawable::OnUpdate()                                  │\r\n│  → Get background color from RSProperties                               │\r\n│  → Create DrawCmdList with drawing commands                             │\r\n│  → Record: DrawRect with Brush(color)                                   │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n                                │\r\n                                ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│                     RENDER PHASE                                         │\r\n│                                                                         │\r\n│  RSBackgroundColorDrawable::OnDraw(canvas)                              │\r\n│  → Execute recorded DrawCmdList                                         │\r\n│  → canvas.DrawRect(bounds, brush)                                       │\r\n│  → ACTUAL GPU RENDERING HAPPENS HERE                                    │\r\n│  → Background color appears on screen                                   │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Important File Locations\r\n\r\n| Component | Location |\r\n|-----------|----------|\r\n| Client Modifiers | `rosen/modules/render_service_client/core/modifier_ng/` |\r\n| Client Properties | `rosen/modules/render_service_client/core/modifier/` |\r\n| Server Modifiers | `rosen/modules/render_service_base/include/modifier_ng/` |\r\n| RSProperties | `rosen/modules/render_service_base/src/property/` |\r\n| Drawables (include) | `rosen/modules/render_service_base/include/drawable/` |\r\n| Property Drawables (src) | `rosen/modules/render_service_base/src/drawable/` |\r\n| Render Node Drawables | `rosen/modules/render_service/core/drawable/` |\r\n\r\n---\r\n\r\n## Glossary\r\n\r\n| Term | Description |\r\n|------|-------------|\r\n| **NG** | Next Generation - enhanced implementations with better performance |\r\n| **RS** | Render Service - prefix for Rosen rendering framework classes |\r\n| **Dirty Flag** | Marker indicating something has changed and needs update |\r\n| **Staging Value** | Value set by client, not yet applied to rendering |\r\n| **Showing Value** | Current value being displayed (used during animation) |\r\n| **Slot** | Rendering order category for drawables (RSDrawableSlot) |\r\n| **Modifier** | Object encapsulating visual properties of a node |\r\n| **Property** | Individual value within a modifier (e.g., color, alpha) |\r\n| **Drawable** | Rendering unit that actually draws on GPU |\r\n| **Prepare Phase** | Update properties and create drawables (no rendering) |\r\n| **Render Phase** | Actual GPU rendering using prepared drawables |\r\n| **RSProperties** | Server-side collection of all property values |\r\n\r\n---\r\n\r\n## Key Design Patterns\r\n\r\n1. **Factory Pattern**: Drawable creation through `OnGenerate()` static methods\r\n2. **Dirty Flag Pattern**: Optimized updates through dirty tracking\r\n3. **Command Pattern**: RSCommand encapsulates property changes\r\n4. **Template Method**: Property templates (`RSProperty<T>`) for type safety\r\n5. **State Pattern**: RSProperties maintains rendering state\r\n",
  "tags": [
    "OpenHarmony",
    "Graphic 2D",
    "Render Service",
    "Rosen",
    "Tutorial"
  ],
  "publishedAt": "2025-02-05T10:00:00Z"
}