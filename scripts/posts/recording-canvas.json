{
  "title": "Recording Canvas in OpenHarmony Render Service",
  "slug": "recording-canvas-openharmony-render-service",
  "excerpt": "Learn about Recording Canvas, a fundamental concept in OpenHarmony's Render Service that enables deferred rendering by recording drawing operations without immediate execution. Explore DrawCmdList, the three-phase drawable pattern, and efficient IPC optimization.",
  "content": "# Recording Canvas in OpenHarmony Render Service\r\n\r\n## Overview\r\n\r\n**Recording Canvas** is a fundamental concept in OpenHarmony's Render Service that allows recording drawing operations without immediately executing them on a surface. It's an \"empty canvas\" that stores the sequence of draw calls in a data structure called `DrawCmdList` for later playback.\r\n\r\n**Key Characteristics:**\r\n- Records drawing commands without executing them immediately\r\n- Stores commands in `DrawCmdList` for later replay\r\n- Enables efficient IPC and command reuse\r\n- Separates drawing command generation from execution\r\n\r\n**Architecture Summary:**\r\n```\r\nProperty Change → Drawable OnUpdate() → Recording Canvas (records commands)\r\n                                                        ↓\r\n                                                    DrawCmdList (stored)\r\n                                                        ↓\r\n                                              Drawable OnSync() (swap lists)\r\n                                                        ↓\r\n                                              Drawable OnDraw() (playback)\r\n```\r\n\r\n---\r\n\r\n## 1. What is Recording Canvas?\r\n\r\n### Concept\r\n\r\nRecording Canvas is a special type of canvas that doesn't render to any surface. Instead, it captures (records) all drawing operations into an internal data structure (`DrawCmdList`) that can be replayed later on a real canvas.\r\n\r\n### Purpose\r\n\r\n| Purpose | Description |\r\n|---------|-------------|\r\n| **Decoupled Drawing** | Separate drawing command generation from execution |\r\n| **Command Reuse** | Record once, replay multiple times |\r\n| **Efficient IPC** | Send commands instead of raw pixel data |\r\n| **Performance** | Batch and optimize drawing commands before execution |\r\n\r\n### Recording vs Real-time Canvas\r\n\r\n| Aspect | Recording Canvas | Real-time Canvas |\r\n|--------|------------------|------------------|\r\n| **Execution** | Records commands, doesn't draw immediately | Draws immediately to surface |\r\n| **Surface** | No surface attached | Attached to a surface |\r\n| **Output** | DrawCmdList (command list) | GPU/CPU rendering |\r\n| **Use Case** | Preparation, command generation | Immediate visual output |\r\n\r\n---\r\n\r\n## 2. Key Classes and Architecture\r\n\r\n### Core Classes\r\n\r\n| Class | Location | Purpose |\r\n|-------|----------|---------|\r\n| `Drawing::RecordingCanvas` | `rosen/modules/2d_graphics/include/recording/recording_canvas.h` | Base recording canvas implementation |\r\n| `ExtendRecordingCanvas` | `rosen/modules/render_service_base/include/pipeline/rs_recording_canvas.h` | Render Service extension with pooling |\r\n| `Drawing::DrawCmdList` | `rosen/modules/2d_graphics/include/recording/draw_cmd_list.h` | Container for recorded commands |\r\n| `RSPropertyDrawCmdListUpdater` | `rosen/modules/render_service_base/include/drawable/rs_property_drawable.h` | Helper for updating drawables |\r\n\r\n### DrawCmdList Storage Modes\r\n\r\n```cpp\r\nenum class DrawCmdListMode {\r\n    IMMEDIATE,  // Contiguous buffer for fast playback\r\n    DEFERRED,   // Vector of command objects for flexibility\r\n};\r\n```\r\n\r\n---\r\n\r\n## 3. How Recording Canvas Works\r\n\r\n### 3.1 Recording Process\r\n\r\n**Step 1: Create Recording Canvas**\r\n```cpp\r\nauto recordingCanvas = std::make_shared<ExtendRecordingCanvas>(width, height, false);\r\n```\r\n\r\n**Step 2: Record Drawing Commands**\r\n```cpp\r\n// These operations are recorded, not executed\r\nrecordingCanvas->DrawRect(rect);\r\nrecordingCanvas->DrawCircle(center, radius);\r\nrecordingCanvas->DrawImage(image, x, y);\r\nrecordingCanvas->Translate(x, y);\r\n```\r\n\r\n**Step 3: Extract DrawCmdList**\r\n```cpp\r\nauto drawCmdList = recordingCanvas->GetDrawCmdList();\r\n```\r\n\r\n### 3.2 Playback Process\r\n\r\n```cpp\r\n// Replay recorded commands on a real canvas\r\ndrawCmdList->Playback(*canvas, &rect);\r\n```\r\n\r\n### 3.3 Recording Flow Diagram\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  1. Create Recording Canvas                                            │\r\n│     - No surface attached                                               │\r\n│     - Ready to record commands                                         │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  2. Call Drawing Methods                                              │\r\n│     - DrawRect(), DrawCircle(), DrawImage(), etc.                    │\r\n│     - Each call creates a DrawOpItem                                 │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  3. Store in DrawCmdList                                               │\r\n│     - Commands stored in IMMEDIATE or DEFERRED mode                   │\r\n│     - Canvas state also preserved (matrices, clips, brushes)         │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  4. Get DrawCmdList                                                     │\r\n│     - Extract command list from canvas                                │\r\n│     - Ready for storage or transmission                                │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## 4. Recording Canvas in Drawables\r\n\r\n### The Three-Phase Pattern\r\n\r\nDrawables use Recording Canvas in a specific three-phase pattern:\r\n\r\n#### Phase 1: OnUpdate (Record)\r\n\r\nLocation: Property drawables use `RSPropertyDrawCmdListUpdater`\r\n\r\n```cpp\r\nbool RSBackgroundColorDrawable::OnUpdate(const RSRenderNode& node)\r\n{\r\n    // Create updater with recording canvas\r\n    RSPropertyDrawCmdListUpdater updater(0, 0, this);\r\n    Drawing::Canvas& canvas = *updater.GetRecordingCanvas();\r\n\r\n    // Get properties and record drawing commands\r\n    const RSProperties& properties = node.GetRenderProperties();\r\n    auto bgColor = properties.GetBackgroundColor();\r\n\r\n    // Record drawing operations (NOT executed yet)\r\n    Drawing::Brush brush;\r\n    brush.SetColor(bgColor.ConvertToDrawingColor());\r\n    canvas.AttachBrush(brush);\r\n    canvas.DrawRect(RSPropertiesPainter::Rect2DrawingRect(properties.GetBoundsRect()));\r\n    canvas.DetachBrush();\r\n\r\n    // updater destructor automatically commits to staging list\r\n    return true;\r\n}\r\n```\r\n\r\n#### Phase 2: OnSync (Commit)\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_property_drawable.cpp`\r\n\r\n```cpp\r\nvoid RSPropertyDrawable::OnSync()\r\n{\r\n    if (needSync_) {\r\n        // Swap staging and actual command lists\r\n        std::swap(drawCmdList_, stagingDrawCmdList_);\r\n        needSync_ = false;\r\n    }\r\n}\r\n```\r\n\r\n#### Phase 3: OnDraw (Playback)\r\n\r\n```cpp\r\nvoid RSPropertyDrawable::OnDraw(Drawing::Canvas* canvas, const Rect* rect) const\r\n{\r\n    if (drawCmdList_) {\r\n        // Playback the recorded commands on real canvas\r\n        drawCmdList_->Playback(*canvas, rect);\r\n    }\r\n}\r\n```\r\n\r\n### Complete Drawable Flow with Recording Canvas\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  PREPARE PHASE: OnUpdate()                                            │\r\n│                                                                         │\r\n│  1. Create RSPropertyDrawCmdListUpdater                               │\r\n│     → Creates recording canvas internally                             │\r\n│                                                                         │\r\n│  2. Get recording canvas: updater.GetRecordingCanvas()                │\r\n│                                                                         │\r\n│  3. Record drawing commands:                                           │\r\n│     canvas.DrawRect(), canvas.DrawCircle(), etc.                      │\r\n│     → Commands stored in stagingDrawCmdList_                         │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  SYNC PHASE: OnSync()                                                  │\r\n│                                                                         │\r\n│  Swap stagingDrawCmdList_ → drawCmdList_                              │\r\n│  (Atomically commit new commands)                                      │\r\n└──────────────────────────────────────┬──────────────────────────────────┘\r\n                                       │\r\n                                       ▼\r\n┌─────────────────────────────────────────────────────────────────────────┐\r\n│  RENDER PHASE: OnDraw()                                                │\r\n│                                                                         │\r\n│  drawCmdList_->Playback(*canvas, rect)                                 │\r\n│  → Execute recorded commands on real canvas                            │\r\n│  → ACTUAL GPU RENDERING HAPPENS HERE                                   │\r\n└─────────────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## 5. RSPropertyDrawCmdListUpdater\r\n\r\n### Overview\r\n\r\nHelper class that manages the recording canvas lifecycle for property drawables.\r\n\r\nLocation: `rosen/modules/render_service_base/include/drawable/rs_property_drawable.h`\r\n\r\n### Key Functionality\r\n\r\n```cpp\r\nclass RSPropertyDrawCmdListUpdater {\r\npublic:\r\n    RSPropertyDrawCmdListUpdater(int32_t x, int32_t y, RSPropertyDrawable* drawable);\r\n    ~RSPropertyDrawCmdListUpdater();\r\n\r\n    // Get the recording canvas for command recording\r\n    Drawing::Canvas* GetRecordingCanvas();\r\n\r\nprivate:\r\n    // On destruction, commits commands to drawable's staging list\r\n    void Commit();\r\n};\r\n```\r\n\r\n### Usage Pattern\r\n\r\n```cpp\r\n// Automatic management with RAII\r\n{\r\n    RSPropertyDrawCmdListUpdater updater(0, 0, this);\r\n    Drawing::Canvas& canvas = *updater.GetRecordingCanvas();\r\n\r\n    // Record commands...\r\n    canvas.DrawRect(...);\r\n\r\n    // Commands automatically committed on scope exit\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. ExtendRecordingCanvas\r\n\r\n### Overview\r\n\r\nRender Service's extended version of Recording Canvas with additional features.\r\n\r\nLocation: `rosen/modules/render_service_base/include/pipeline/rs_recording_canvas.h`\r\n\r\n### Key Features\r\n\r\n```cpp\r\nclass ExtendRecordingCanvas : public Drawing::RecordingCanvas {\r\npublic:\r\n    ExtendRecordingCanvas(int32_t width, int32_t height, bool detach)\r\n        : RecordingCanvas(width, height, Drawing::FontSpacing::fontSpacingFlag_) {}\r\n\r\n    // Additional drawing methods for media integration\r\n    void DrawImage(const Drawing::Image& image, int x, int y,\r\n                   const Drawing::SamplingOptions& samplingOptions);\r\n    void DrawImageRect(const Drawing::Image& image, const Drawing::Rect& src,\r\n                       const Drawing::Rect& dst);\r\n\r\n    // Custom drawing function support\r\n    using CustomDrawFunction = std::function<void(Drawing::Canvas*)>;\r\n    void SetCustomDrawFunction(CustomDrawFunction func);\r\n    void ExecuteCustomDrawFunction();\r\n};\r\n```\r\n\r\n### Canvas Pooling\r\n\r\nFor performance, recording canvases are pooled and reused:\r\n\r\n```cpp\r\nclass RSCanvasCache {\r\npublic:\r\n    static std::shared_ptr<ExtendRecordingCanvas> GetRecordingCanvas(\r\n        int32_t width, int32_t height, bool detach = false);\r\n\r\n    static void RecycleRecordingCanvas(\r\n        std::shared_ptr<ExtendRecordingCanvas> canvas);\r\n};\r\n```\r\n\r\n---\r\n\r\n## 7. Real Usage Examples\r\n\r\n### 7.1 Background Color Drawable\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_property_drawable_background.cpp`\r\n\r\n```cpp\r\nbool RSBackgroundColorDrawable::OnUpdate(const RSRenderNode& node)\r\n{\r\n    const RSProperties& properties = node.GetRenderProperties();\r\n    auto bgColor = properties.GetBackgroundColor();\r\n\r\n    if (bgColor == RgbPalette::Transparent()) {\r\n        return false;  // No drawable needed\r\n    }\r\n\r\n    // Record drawing commands\r\n    RSPropertyDrawCmdListUpdater updater(0, 0, this);\r\n    Drawing::Canvas& canvas = *updater.GetRecordingCanvas();\r\n\r\n    Drawing::Brush brush;\r\n    if (bgColor.GetColorSpace() == GraphicColorGamut::GRAPHIC_COLOR_GAMUT_SRGB) {\r\n        brush.SetColor(bgColor.ConvertToDrawingColor());\r\n    } else {\r\n        // P3 color space handling\r\n        brush.SetColor(bgColor.GetColor4f(),\r\n            Drawing::ColorSpace::CreateRGB(Drawing::CMSTransferFuncType::SRGB,\r\n                                             Drawing::CMSMatrixType::DCIP3));\r\n    }\r\n\r\n    canvas.AttachBrush(brush);\r\n    canvas.DrawRect(RSPropertiesPainter::Rect2DrawingRect(properties.GetBoundsRect()));\r\n    canvas.DetachBrush();\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n### 7.2 Border Drawable\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_property_drawable_border.cpp`\r\n\r\n```cpp\r\nbool RSBorderDrawable::OnUpdate(const RSRenderNode& node)\r\n{\r\n    RSPropertyDrawCmdListUpdater updater(0, 0, this);\r\n    Drawing::Canvas& canvas = *updater.GetRecordingCanvas();\r\n\r\n    const RSProperties& properties = node.GetRenderProperties();\r\n    const auto& border = properties.GetBorder();\r\n\r\n    // Record border drawing commands\r\n    Drawing::Brush brush;\r\n    brush.SetColor(Drawing::Color(border.GetColor().AsArgbInt()));\r\n    brush.SetAntiAlias(true);\r\n    canvas.AttachBrush(brush);\r\n\r\n    auto rRect = RSPropertyDrawableUtils::RRect2DrawingRRect(properties.GetRRect());\r\n    canvas.DrawRoundRect(rRect);  // Recorded, not executed\r\n\r\n    canvas.DetachBrush();\r\n    return true;\r\n}\r\n```\r\n\r\n### 7.3 Shadow Drawable\r\n\r\nLocation: `rosen/modules/render_service_base/src/drawable/rs_property_drawable_shadow.cpp`\r\n\r\n```cpp\r\nbool RSShadowDrawable::OnUpdate(const RSRenderNode& node)\r\n{\r\n    RSPropertyDrawCmdListUpdater updater(0, 0, this);\r\n    Drawing::Canvas& canvas = *updater.GetRecordingCanvas();\r\n\r\n    const RSProperties& properties = node.GetRenderProperties();\r\n\r\n    // Get shadow properties\r\n    auto shadowColor = properties.GetShadowColor();\r\n    auto shadowOffsetX = properties.GetShadowOffsetX();\r\n    auto shadowOffsetY = properties.GetShadowOffsetY();\r\n    auto shadowRadius = properties.GetShadowRadius();\r\n\r\n    // Record shadow drawing commands\r\n    RecordingCanvasHelper::DrawShadow(\r\n        canvas,\r\n        properties.GetBoundsRect(),\r\n        shadowColor,\r\n        shadowOffsetX,\r\n        shadowOffsetY,\r\n        shadowRadius\r\n    );\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n### 7.4 Canvas Drawing Node\r\n\r\nLocation: `rosen/modules/render_service/core/drawable/rs_canvas_drawing_render_node_drawable.cpp`\r\n\r\n```cpp\r\nvoid RSCanvasDrawingRenderNodeDrawable::DrawContent(Drawing::Canvas& canvas)\r\n{\r\n    if (recordingCanvas_) {\r\n        auto cmds = recordingCanvas_->GetDrawCmdList();\r\n        if (cmds && !cmds->IsEmpty()) {\r\n            // Replay recorded commands\r\n            cmds->Playback(canvas);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. DrawCmdList Details\r\n\r\n### Command Types\r\n\r\nEach drawing operation becomes a specific command type:\r\n\r\n| Command Type | Operation |\r\n|--------------|-----------|\r\n| `DrawRectOpItem` | Draw rectangle |\r\n| `DrawRoundRectOpItem` | Draw rounded rectangle |\r\n| `DrawCircleOpItem` | Draw circle |\r\n| `DrawOvalOpItem` | Draw oval |\r\n| `DrawPathOpItem` | Draw path |\r\n| `DrawImageOpItem` | Draw image |\r\n| `DrawTextOpItem` | Draw text |\r\n| `ClipRectOpItem` | Clip to rectangle |\r\n| `ClipRoundRectOpItem` | Clip to rounded rectangle |\r\n| `SaveOpItem` | Save canvas state |\r\n| `RestoreOpItem` | Restore canvas state |\r\n| `TranslateOpItem` | Translate canvas |\r\n| `RotateOpItem` | Rotate canvas |\r\n| `ScaleOpItem` | Scale canvas |\r\n\r\n### IMMEDIATE vs DEFERRED Mode\r\n\r\n| Mode | Storage | Performance | Use Case |\r\n|------|---------|-------------|----------|\r\n| **IMMEDIATE** | Contiguous buffer | Faster playback | Most common cases |\r\n| **DEFERRED** | Vector of objects | More flexible | Dynamic modifications |\r\n\r\n### Command Marshalling\r\n\r\nDrawCmdList supports IPC marshalling for client-server communication:\r\n\r\n```cpp\r\nclass DrawCmdList : public Parcelable {\r\npublic:\r\n    // Marshalling for IPC\r\n    bool Marshalling(Parcel& parcel) const override;\r\n    static DrawCmdList* Unmarshalling(Parcel& parcel);\r\n\r\n    // Playback methods\r\n    void Playback(Canvas& canvas) const;\r\n    void Playback(Canvas& canvas, const Rect* rect) const;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 9. Important File Locations\r\n\r\n| Component | Location |\r\n|-----------|----------|\r\n| Recording Canvas (base) | `rosen/modules/2d_graphics/include/recording/recording_canvas.h` |\r\n| Recording Canvas (impl) | `rosen/modules/2d_graphics/src/recording/recording_canvas.cpp` |\r\n| DrawCmdList | `rosen/modules/2d_graphics/include/recording/draw_cmd_list.h` |\r\n| ExtendRecordingCanvas | `rosen/modules/render_service_base/include/pipeline/rs_recording_canvas.h` |\r\n| RSPropertyDrawCmdListUpdater | `rosen/modules/render_service_base/include/drawable/rs_property_drawable.h` |\r\n| Background Drawable | `rosen/modules/render_service_base/src/drawable/rs_property_drawable_background.cpp` |\r\n| Border Drawable | `rosen/modules/render_service_base/src/drawable/rs_property_drawable_border.cpp` |\r\n| Shadow Drawable | `rosen/modules/render_service_base/src/drawable/rs_property_drawable_shadow.cpp` |\r\n| Canvas Drawing Drawable | `rosen/modules/render_service/core/drawable/rs_canvas_drawing_render_node_drawable.cpp` |\r\n\r\n---\r\n\r\n## 10. Key Concepts Summary\r\n\r\n### Recording Canvas Flow\r\n\r\n```\r\nProperty Change\r\n       ↓\r\nDrawable OnUpdate()\r\n       ↓\r\nCreate RSPropertyDrawCmdListUpdater\r\n       ↓\r\nGet Recording Canvas\r\n       ↓\r\nRecord Commands (DrawRect, DrawCircle, etc.)\r\n       ↓\r\nCommands stored in stagingDrawCmdList_\r\n       ↓\r\nOnSync() - Swap staging → actual\r\n       ↓\r\nOnDraw() - Playback on real canvas\r\n       ↓\r\nGPU Rendering\r\n```\r\n\r\n### Why Recording Canvas?\r\n\r\n1. **Separation of Concerns**: Drawing logic separated from execution\r\n2. **Efficiency**: Commands can be optimized before execution\r\n3. **Reusability**: Same commands can be replayed multiple times\r\n4. **Thread Safety**: Recording on one thread, playback on another\r\n5. **IPC Optimization**: Send commands instead of pixel data\r\n\r\n### Design Patterns Used\r\n\r\n- **Command Pattern**: Drawing operations stored as command objects\r\n- **RAII**: RSPropertyDrawCmdListUpdater manages canvas lifecycle\r\n- **Object Pool**: Canvases are pooled and reused\r\n- **Double Buffering**: staging and actual command lists for thread safety\r\n\r\n---\r\n\r\n## Glossary\r\n\r\n| Term | Description |\r\n|------|-------------|\r\n| **Recording Canvas** | Canvas that records drawing commands instead of executing them |\r\n| **DrawCmdList** | Container storing recorded drawing commands |\r\n| **Playback** | Executing recorded commands on a real canvas |\r\n| **IMMEDIATE Mode** | Commands stored in contiguous buffer for fast playback |\r\n| **DEFERRED Mode** | Commands stored as vector of objects |\r\n| **RSPropertyDrawCmdListUpdater** | RAII helper for managing recording canvas in drawables |\r\n| **ExtendRecordingCanvas** | Render Service's extended recording canvas with pooling |\r\n| **stagingDrawCmdList_** | Temporary command list being recorded |\r\n| **drawCmdList_** | Actual command list used for rendering |\r\n",
  "tags": [
    "OpenHarmony",
    "Graphic 2D",
    "Render Service",
    "Recording Canvas",
    "Rosen",
    "Tutorial"
  ],
  "publishedAt": "2025-02-05T11:00:00Z"
}